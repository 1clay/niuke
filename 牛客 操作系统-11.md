# 牛客 操作系统-11

线程共享的环境包括：进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。


    进程拥有这许多共性的同时，还拥有自己的个性。有了这些个性，线程才能实现并发性。这些个性包括：
    
    1.线程ID
      每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标
   识线程。

    2.寄存器组的值
       由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线
   程切换到另一个线程上 时，必须将原有的线程的寄存器集合的状态保存，以便
   将来该线程在被重新切换到时能得以恢复。

    3.线程的堆栈
       堆栈是保证线程独立运行所必须的。
       线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程
   必须拥有自己的函数堆栈， 使得函数调用可以正常执行，不受其他线程的影
   响。

    4.错误返回码
       由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用
   后设置了errno值，而在该 线程还没有处理这个错误，另外一个线程就在此时
   被调度器投入运行，这样错误值就有可能被修改。
       所以，不同的线程应该拥有自己的错误返回码变量。

    5.线程的信号屏蔽码
       由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理。但所有的线程都共享同样的信号处理器。
    
    6.线程的优先级
       由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的优先级。

 

      涉及多线程程序涉及的时候经常会出现一些令人难以思议的事情，用堆和栈分配一个变量可能在以后的执行中产生意想不到的结果，而这个结果的表现就是内存的非法被访问，导致内存的内容被更改。 

理解这个现象的两个基本概念是：在一个进程的线程共享堆区，而进程中的线程各自维持自己堆栈。 
在 windows 等平台上，不同线程缺省使用同一个堆，所以用 C 的 malloc （或者 windows 的 GlobalAlloc）分配内存的时候是使用了同步保护的。如果没有同步保护，在两个线程同时执行内存操作的时候会产生竞争条件，可能导致堆内内存管理混乱。比如两个线程分配了统一块内存地址，空闲链表指针错误等。 

Symbian 的线程一般使用独立的堆空间。这样每个线程可以直接在自己的堆里分配和释放，可以减少同步所引入的开销。当线程退出的时候，系统直接回收线程的堆空间，线程内没有释放的内存空间也不会造成进程内的内存泄漏。 

但是两个线程使用共用堆的时候，就必须用 critical section 或者 mutex 进行同步保护。否则程序崩溃时早晚的事。如果你的线程需要在共用堆上无规则的分配和释放任何数量和类型的对象，可以定制一个自己的 allcator，在 allocator 内部使用同步保护。线程直接使用这个 allocator 分配内存就可以了。这相当于实现自己的 malloc，free。但是更建议你重新审查一下自己的系统，因为这种情况大多数是不必要的。经过良好的设计，线程的本地堆应该能够满足大多数对象的需求。如果有某一类对象需要在共享堆上创建和共享，这种需求是比较合理的，可以在这个类的 new 和 delete 上实现共享保护。 

##### 死锁产生的四个必要条件

互斥条件：资源是独占的且排他使用，进程互斥使用资源，即任意时刻一个资源只能给一个进程使用，其他进程若申请一个资源，而该资源被另一进程占有时，则申请者等待直到资源被占有者释放。
不可剥夺条件：进程所获得的资源在未使用完毕之前，不被其他进程强行剥夺，而只能由获得该资源的进程资源释放。
请求和保持条件：进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。
循环等待条件：在发生死锁时必然存在一个进程等待队列{P1,P2,…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路，环路中每一个进程所占有的资源同时被另一个申请，也就是前一个进程占有后一个进程所深情地资源。
  以上给出了导致死锁的四个必要条件，只要系统发生死锁则以上四个条件至少有一个成立。事实上循环等待的成立蕴含了前三个条件的成立，似乎没有必要列出然而考虑这些条件对死锁的预防是有利的，因为可以通过破坏四个条件中的任何一个来预防死锁的发生。

##### 死锁预防

  我们可以通过破坏死锁产生的4个必要条件来 预防死锁，由于资源互斥是资源使用的固有特性是无法改变的。
破坏“不可剥夺”条件：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到 系统的资源列表中，可以被其他的进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行。
破坏”请求与保持条件“：第一种方法静态分配即每个进程在开始执行时就申请他所需要的全部资源。第二种是动态分配即每个进程在申请所需要的资源时他本身不占用系统资源。
破坏“循环等待”条件：采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程。

Windows系统中，文件的命名规则：
a.         允许文件或文件夹名称不得超过255个字符

b.         文件名不区分大小写

c.         文件名不能使用：\，/，<，>，*，？，|和”等字符 排除C

d.         要求文件名都必须有扩展名

e.         空格和各种控制符不能出现在文件名中。排除A

f.          文件名称由文件名和扩展名两部分组成，中间用“.” 分割开来。排除D

在引入线程的操作系统中，线程是进程中的一个实体，是系统独立调度和分派的基本单位。但是线程自己基本上不拥有系统资源，所以它不是资源分配的基本单位，它只拥有一部分在运行中必不可少的与处理机相关的资源，如线程状态、寄存器上下文和栈等，它同样有就绪、阻塞和执行三种基本状态。它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程；同一个进程中的多个线程之间可以并发执行。由于用户线程不依赖于操作系统内核，因此，操作系统内核是不知道用户线程的存在的，用户线程是由用户来管理和调度的，用户利用线程库提供的API来创建、同步、调度和管理线程。所以，用户线程的调度在用户程序内部进行，通常采用非抢先式和更简单的规则，也无须用户态和核心态切换，所以速度很快。由于操作系统不知道用户线程的存在，所以，操作系统把CPU的时间片分配给用户进程，再由用户进程的管理器将时间分配给用户线程。那么，用户进程能得到的时间片即为所有用户线程共享。

由于用户线程不依赖于操作系统内核，因此，操作系统内核是不知道用户线程的存在的，用户线程是由用户来管理和调度的，用户利用线程库提供的API来创建、同步、调度和管理线程。所以，用户线程的调度在用户程序内部进行，通常采用非抢先式和更简单的规则，也无须用户态和核心态切换，所以速度很快。
由于操作系统不知道用户线程的存在，所以，操作系统把CPU的时间片分配给用户进程，再由用户进程的管理器将时间分配给用户线程。那么，用户进程能得到的时间片即为所有用户线程共享.

在操作系统中，引入缓冲的主要原因：
1、改善CPU与I/O设备间速度不匹配的矛盾
例如一个程序,它时而进行长时间的计算而没有输出,时而又阵发性把输出送到打印机.由于打印机的速度跟不上CPU,而使得CPU长时间的等待.如果设置了缓冲区,程序输出的数据先送到缓冲区暂存,然后由打印机慢慢地输出.这时,CPU不必等待,可以继续执行程序.实现了CPU与I/O设备之间的并行工作.事实上,凡在数据的到达速率与其离去速率不同的地方,都可设置缓冲,以缓和它们之间速度不匹配的矛盾.众所周知,通常的程序都是时而计算,时而输出的.
2、可以减少对CPU的中断频率，放宽对中断响应时间的限制
如果I/O操作每传送一个字节就要产生一次中断,那么设置了n个字节的缓冲区后,则可以等到缓冲区满才产生中断,这样中断次数就减少到1/n,而且中断响应的时间也可以相应的放宽
3、提高CPU和I/O设备之间的并行性
缓冲的引入可显著提高CPU和设备的并行操作程度，提高系统的吞吐量和设备的利用率
根据I/O控制方式，缓冲的实现方法有两种：
一种是采用专用硬件缓冲器
一种是在内存划出一个具有n个单元的专用缓冲区，以便存放输入/输出的数据，内存缓冲区又称软件缓冲

Java运行时的数据区包括：（其中前两个是线程共享的）
1.方法区（Method Area） 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
2.堆（Heap） 存放对象实例，几乎所有对象实例都在这里分配内存
3.虚拟机栈（VM Stack） 描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个Stack Frame（方法运行时的基础数据结构）用于存储局部变量表、操作数栈、动态连接、方法出口等信息
4.本地方法栈（Native Method Stack）  与虚拟机栈了类似，不过则为虚拟机使用的到的Native方法服务。（有的虚拟机譬如Sun HotSpot虚拟机直接把本地方法栈和虚拟机栈合二为一）
5.程序计数器（Program Counter Register） 可看作当前线程所执行的字节码的行号的标识器