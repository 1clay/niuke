# 牛客 操作系统-23

操作系统执行和监督进程控制操作，往往通过执行各种原语操作实现。计算机控制器的机器指令是微操作构成的，原语是机器指令的延伸，是由若干条机器指令构成用以完成特定功能的一段程序。为保证操作的正确性，它们应当是原子操作(AtomicOperation)。所谓原子操作是指：一个操作中的所有动作，要么全做，要么全不做。原子操作是一个不可分割的操作。它的实现依靠提高处理机优先级屏蔽中断。
进程控制原语包括：进程创建，进程阻塞，唤醒进程和进程终止四个原语。

引入缓冲的主要原因包括：缓和CPU与I/O设备间速度不匹配的矛盾；根据对CPU的中断频率，放宽对中断时间的限制；提高CPU和I/O设备之间的并行性。所以采用缓冲技术，可减少对CPU的中断次数，从而提高系统效率。

**分页机制的作用**：段机制把虚拟地址转换为线性地址，分页机制进一步把该**线性地址再转换为物理地址**。

**基址寄存器**存放页表的起始地址，将虚拟地址中的页号与基址寄存器中内容相加，得到该虚拟地址所在页对应在内存中的页框号，再将页框号与偏移量相加，就得到对应的物理地址。

设备独立性是指用户不指定特定的设备，而指定逻辑设备，使得用户作业和物理设备独立开来，再通过其他途径建立逻辑设备和物理设备之间的对应关系的特性；即用户程序独立于具体使用的物理设备的一种特性。

Unix系统中把进程控制块分成proc结构和user结构两部分, proc存放的是系统经常要查询和修改的信息，需要快速访问，因此常将其装入内存，常驻内存；而user部分，随着进程的状态而动态变化，比如进程挂起。

内存重定位：操作系统将程序指令中的相对地址转换为内存中的绝对过程；

动态重定位：将内存重定位延迟到程序执行的时候进行称为动态重定位技术，动态加载和连接类似

为了支持多道程序系统和分时系统，支持多个程序并发执行，引入了分区式存储管理。分区式存储管理是把内存分为一些大小相等或不等的分区，操作系统占用其中一个分区，其余的分区由应用程序使用，每个应用程序占用一个或几个分区。分区式存储管理虽然可以支持并发，但难以进行内存分区的共享。 常用的分区方法有固定分区和动态分区，而动态分区中常用的分区分配算法有首次适配法，下次适配法，最佳适配法，最差适配法。 为了解决分区分配带来的碎片问题，引入了伙伴系统:无论已分配分区或空闲分区，其大小均为2的k次幂。在系统运行过程中，由于不断的划分，可能会形成若干个不连续的空闲分区，将这些空闲分区根据分区的大小进行分类，对于每一类具有相同大小的所有空闲分区，单独设立一个空闲分区双向链表。这样，不同大小的空闲分区形成了k个空闲分区链表。

最先适应算法：依次判定后找到第一个满足要求的哈
最佳适应算法：对空闲区按从小到大排序，第一个满足的就是啦
最差适应算法：对空闲区按从大到小排序，第一个满足的就是啦

固定式分区算法：是分区的

进程中的几种通信方式：

1）管道：管道是一种半双工的通信方式，数据只能单向流动。而且只能在具有血缘关系（父子进程之间）的的进程间使用。

2）信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问

3）消息队列：消息队列是由消息组成的链表，存放在内核中，并由消息队列标识符标识

4）信号：信号是有一种比较复杂的通信方式，用于通知接收进程某一事件已经发生

5）共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问

6）套接字：即Socket，是一种通信机制，凭借这种机制，客户/服务器系统的开发工作既可以在本地单机上进行，也可以跨网络进行

多道程序设计是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制之下，相互穿插的运行。 两个或两个以上程序在计算机系统中同处于开始到结束之间的状态。这就称为多道程序设计。

计算机内存的保证，主要目的是提高CPU的利用率，当CPU充分利用时，再多就不能再提高系统效率。

对于Linux内核来说，并不区分进程和线程。在创建进程或者线程时，都会调用fork()函数，在fork()内部会调用clone()实现创建的功能，而进程和线程的区别就在这里：在调用clone()函数时，如果创建的是线程，需要传递一些参数标志来指明需要共享的资源，因为线程是在进程内部，多个线程可以共享进程的一些资源。对于常说的进程是"资源分配的基本单位"，我的理解是因为咱们在调用fork()创建进程时需要给每个进程创建独立的进程地址空间；而对于线程就不需要，因为它会与进程共享一块地址空间。常说的"线程是CPU调度的最小单位"，我的理解是：像对于常见Linux调度器，比如CFS，实时调度器等都是以线程为基本单位来进行调度，因此是这样的说法。

CPU状态分为管态和目态，管态又称为特权态，系统态或核心态。CPU在管态下可以执行指令系统的全集。通常，操作系统在管态下运行。
目态又称为常态或用户态。机器处于目态时，程序只能执行非特权指令。用户程序只能在目态下运行，如果用户程序在目态下执行特权指令，硬件将发生中断，由操作系统获得控制，特权指令执行被禁止，这样可以防止用户程序有意或无意地破坏系统。