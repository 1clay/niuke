# 牛客 操作系统-6

对于CPU而言，影响其性能的指标主要有**主频****、 CPU的位数以及CPU的缓存指令集**。 

- **主频**，指的就是时钟频率（也可以对应周期），它直接的决定了CPU的性能。 
- **位数**指的就是处理器能够一次性计算的浮点数的位数，通常情况下，CPU的位数越高，CPU 进行运算时候的速度就会变得越快。处理字长为8位数据的CPU叫8位CPU，32位CPU就是在同一时间内处理字长为32位的二进制数据。 
- **缓存指令集**是存储在CPU内部的，主要指的是能够对CPU的运算进行指导以及优化的硬程序。

线程上下文切换和进程上下问切换一个最主要的区别    线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。 

另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。    简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个 显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（processor’s Translation Lookaside Buffer (TLB)）或者相当的神马东西会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题。 

进程间切换的步骤： 

1，保存程序计数其以及其他寄存器。 

2， 更新当前处于“运行态”的进程的进程控制块，把进程状态改为相应状态，更新其他相关域 

3， 把被切换进程的进程控制块移到相关状态的队列 

4， 选择另外一个进程开始执行，把该进程进程控制块的状态改为“运行态” 

5， 恢复被选择进程的处理器在最近一次被切换出运行态时的上下文，比如载入程序计数器以及其他处理器的值 

进程间切换伴随着两次模式切换（用户--内核，内核--用户）。 

（同一进程内）线程间切换的步骤： 

线程分两种，用户级线程和内核级线程 

在用户级线程中，有关线程管理的所有工作都由应用程序完成，内核没有意识到线程的存在。 

（同一进程内）用户级线程间切换时，只需要保存用户寄存器的内容，程序计数器，栈指针，不需要模式切换。 

缺点： 

1， 在进程的某个线程执行系统调用时，不仅该线程被阻塞，该线程所在进程的所有线程都被阻塞 

2， 无法利用多处理器 

在内核级线程中，有关线程的管理工作都是由内核完成的，应用程序部分没有线程管理的权限，只有一个接口（API) 

（同一进程内）内核级线程间切换时，除了保存上下文，还要进行模式切换。 

优点： 

1， 可以利用多处理器 

2， 线程阻塞不会导致进程阻塞 

可能切换，要看下一个被调度的线程和当前线程是否属于同一进程。如果不属于才切换页表，更换进程用户空间，否则只是从事一些线程级别工作，不会切换进程的

1.SPOOLing （即外部设备联机并行操作），即Simultaneous Peripheral Operation On-Line的缩写，它是关于慢速字符设备如何与计算机主机交换信息的一种技术，通常称为“假脱机技术” 2.SPOOLing 技术特点： (1)提高了I/O速度.从对低速I/O设备进行的I/O操作变为对输入井或输出井的操作,如同脱机操作一样,提高了I/O速度,缓和了CPU与低速I/O设备速度不匹配的矛盾. (2)设备并没有分配给任何进程.在输入井或输出井中,分配给进程的是一存储区和建立一张I/O请求表. (3)实现了虚拟设备功能.多个进程同时使用一独享设备,而对每一进程而言,都认为自己独占这一设备,不过,该设备是逻辑上的设备.

A.批处理是指用户将一批作业提交给操作系统后就不再干预，由操作系统控制它们自动运行。

B.分时操作系统是使一台计算机采用时间片轮转的方式同时为几个、几十个甚至几百个用户服务的一种操作系统。由于时间间隔很短，每个用户的感觉就像他独占计算机一样。

C.实时操作系统(RTOS)是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统做出快速响应，并控制所有实时任务协调一致运行的操作系统。

D.网络操作系统，是一种能代替操作系统的软件程序，是网络的心脏和灵魂，是向网络计算机提供服务的特殊的操作系统。

进程数超过一定程度，就有由于大量进程间切换而耗费过多的cpu资源，所以利用率反而下降

**buddy内存分配算法**

**1、优缺点**

1）、 一个很小的块往往会阻碍一个大块的合并，一个系统中，对内存块的分配，大小是随机的，一片内存中仅一个小的内存块没有释放，旁边两个大的就不能合并。

2）、 算法中有一定的浪费现象，伙伴算法是**按2的幂次方大小进行分配内存块**，当然这样做是有原因的，即为了避免把大的内存块拆的太碎，更重要的是使分配和释放过程迅速。但是他也带来了不利的一面，如果所需内存大小不是2的幂次方，就会有部分页面浪费。有时还很严重。

3）、 另外拆分和合并涉及到 较多的链表和位图操作，开销还是比较大的。

**2、** Buddy（伙伴的定义）：

这里给出伙伴的概念，满足以下三个条件的称为伙伴： **1）两个块大小相同；** **2）两个块地址连续；**

**3）两个块必须是同一个大块中分离出来的；**

3、Buddy算法的释放原理： 

内存的释放是分配的逆过程，也可以看作是伙伴的合并过程。当释放一个块时，先在其对应的链表中考查是否有伙伴存在，如果没有伙伴块，就直接把要释放的块挂入链表头；如果有，则从链表中摘下伙伴，合并成一个大块，然后继续考察合并后的块在更大一级链表中是否有伙伴存在，直到不能合并或者已经合并到了最大的块(2*2*2*2*2*2*2*2*2个页面)。 

![img](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)

**整个过程中，位图扮演了重要的角色**，如图2所示，位图的某一位对应两个互为伙伴的块，为1表示其中一块已经分配出去了，为0表示两块都空闲。伙伴中无论是分配还是释放都只是相对的位图进行异或操作。分配内存时对位图的是为释放过程服务，释放过程根据位图判断伙伴是否存在，如果对相应位的异或操作得1，则没有伙伴可以合并，如果异或操作得0，就进行合并，并且继续按这种方式合并伙伴，直到不能合并为止。