# 牛客 操作系统-4

计算机系统中的死锁 

1.竞争不可抢占性资源引起死锁 

2.竞争可消耗资源引起死锁 

3.进程推进顺序不当引起死锁 

产生死锁的必要条件 

1.互斥条件 

2.请求和保持条件 

3.不可抢占条件 

4.循环等待条件 

处理死锁的方法 

1.预防死锁 

2.避免死锁 

3.检测死锁 

4.解除死锁 

预防死锁（主要是破坏产生死锁的后三个条件） 

1.破坏‘请求和保持’条件 

2.破坏‘不可抢占条件’条件 

3.破坏‘循环等待’条件

异常，也成为内中断，也成为例外或者陷入，指源自CPU执行指令内部的事件，如程序的非法操作码，地址越界，算术溢出、虚存系统的缺页以及专门的陷入指令等引起的。

皮特森算法，两个flag保证进程之间的互斥，但是可能存在死锁，互相阻塞的情况，这个时候就采用turn来决定执行的进程

一般地，解决死锁的方法分为死锁的预防，避免，检测与恢复三种（注意：死锁的检测与恢复是一个方法）

**死锁的预防**是保证系统不进入死锁状态的一种策略。它的基本思想是要求进程申请资源时遵循某种协议，从而打破产生死锁的四个必要条件中的一个或几个，保证系统不会进入死锁状态。

**死锁的避免，**它不限制进程有关申请资源的命令，而是对进程所发出的每一个申请资源命令加以动态地检查，并根据检查结果决定是否进行资源分配。就是说，在资源分配过程中若预测有发生死锁的可能性，则加以避免。这种方法的关键是确定资源分配的安全性。

**死锁的检测与恢复  ，** 一般来说，由于操作系统有并发，共享以及随机性等特点，通过预防和避免的手段达到排除死锁的目的是很困难的。这需要较大的系统开销，而且不能充分利用资源。为此，一种简便的方法是系统为进程分配资源时，不采取任何限制性措施，但是提供了检测和解脱死锁的手段：能发现死锁并从死锁状态中恢复出来。因此，在实际的操作系统中往往采用死锁的检测与恢复方法来排除死锁。 死锁检测与恢复是指系统设有专门的机构，当死锁发生时，该机构能够检测到死锁发生的位置和原因，并能通过外力破坏死锁发生的必要条件，从而使得并发进程从死锁状态中恢复出来。

就绪队列是处于就绪状态线程（进程）排队的队列，就绪状态线程是有执行资格的只是在等时间片分配，而等待队列是阻塞状态线程（进程）排队的队列，阻塞状态线程是获取资源没获取到然后阻塞等待的，没获取到资源是没有执行资格的， 根据题意没有线程运行，应该是就绪队列为空，而等待队列中可能有线程没有获取到资源，仍然在等待

在[存储器管理](https://baike.baidu.com/item/存储器管理/6627083)中，连续分配方式会形成许多“碎片”，虽然可通过“紧凑”方法将许多碎片拼接成可用的大块空间，但须为之付出很大开销。

如果允许将一个[进程](https://baike.baidu.com/item/进程/382503)直接分散地装入到许多不相邻的分区中，则无须再进行“紧凑”。基于这一思想而产生了[离散](https://baike.baidu.com/item/离散/858263)分配方式。如果离散分配的基本单位是页，则称为分页存储管理方式。在分页存储管理方式中，如果不具备[页面](https://baike.baidu.com/item/页面/5544813)[对换](https://baike.baidu.com/item/对换/2817180)功能，则称为基本分页存储管理方式，或称为纯分页存储管理方式，它不具有支持实现[虚拟存储器](https://baike.baidu.com/item/虚拟存储器/944209)的功能，它要求把每个作业全部装入内存后方能运行。

四种常见的线程池： CachedThreadPool:可缓存的线程池，该线程池中没有核心线程，非核心**线程的数量为Integer.max_value，就是无限大**，当有需要时创建线程来执行任务，没有需要时回收线程，适用于耗时少，任务量大的情况。 SecudleThreadPool:周期性执行任务的线程池，按照某种特定的计划执行线程中的任务，有核心线程，但也有非核心线程，非核心线程的大小也为无限大。适用于执行周期性的任务。 SingleThreadPool:只有一条线程来执行任务，适用于有顺序的任务的应用场景。 FixedThreadPool:定长的线程池，有核心线程，核心线程的即为最大的线程数量，没有非核心线程

线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的[堆栈](https://baike.baidu.com/item/堆栈)大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在[托管代码](https://baike.baidu.com/item/托管代码)中空闲（如正在等待某个事件）,则线程池将插入另一个[辅助线程](https://baike.baidu.com/item/辅助线程)来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。